{"remainingRequest":"/Users/takanosayaka/Documents/GitHub/makeup_flowchart_vue3/node_modules/babel-loader/lib/index.js!/Users/takanosayaka/Documents/GitHub/makeup_flowchart_vue3/node_modules/vue-loader-v16/dist/templateLoader.js??ref--6!/Users/takanosayaka/Documents/GitHub/makeup_flowchart_vue3/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/takanosayaka/Documents/GitHub/makeup_flowchart_vue3/node_modules/vue-loader-v16/dist/index.js??ref--1-1!/Users/takanosayaka/Documents/GitHub/makeup_flowchart_vue3/src/views/Flowchart.vue?vue&type=template&id=0f1af2a6","dependencies":[{"path":"/Users/takanosayaka/Documents/GitHub/makeup_flowchart_vue3/src/views/Flowchart.vue","mtime":1664453635767},{"path":"/Users/takanosayaka/Documents/GitHub/makeup_flowchart_vue3/babel.config.js","mtime":1661341671887},{"path":"/Users/takanosayaka/Documents/GitHub/makeup_flowchart_vue3/node_modules/cache-loader/dist/cjs.js","mtime":1663381957340},{"path":"/Users/takanosayaka/Documents/GitHub/makeup_flowchart_vue3/node_modules/babel-loader/lib/index.js","mtime":1663381957251},{"path":"/Users/takanosayaka/Documents/GitHub/makeup_flowchart_vue3/node_modules/vue-loader-v16/dist/templateLoader.js","mtime":1663381993401},{"path":"/Users/takanosayaka/Documents/GitHub/makeup_flowchart_vue3/node_modules/cache-loader/dist/cjs.js","mtime":1663381957340},{"path":"/Users/takanosayaka/Documents/GitHub/makeup_flowchart_vue3/node_modules/vue-loader-v16/dist/index.js","mtime":1663381993401}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IHsgY3JlYXRlVk5vZGUgYXMgX2NyZWF0ZVZOb2RlLCBjcmVhdGVDb21tZW50Vk5vZGUgYXMgX2NyZWF0ZUNvbW1lbnRWTm9kZSwgY3JlYXRlRWxlbWVudFZOb2RlIGFzIF9jcmVhdGVFbGVtZW50Vk5vZGUsIG5vcm1hbGl6ZVByb3BzIGFzIF9ub3JtYWxpemVQcm9wcywgZ3VhcmRSZWFjdGl2ZVByb3BzIGFzIF9ndWFyZFJlYWN0aXZlUHJvcHMsIHdpdGhNb2RpZmllcnMgYXMgX3dpdGhNb2RpZmllcnMsIHdpdGhDdHggYXMgX3dpdGhDdHgsIEZyYWdtZW50IGFzIF9GcmFnbWVudCwgb3BlbkJsb2NrIGFzIF9vcGVuQmxvY2ssIGNyZWF0ZUVsZW1lbnRCbG9jayBhcyBfY3JlYXRlRWxlbWVudEJsb2NrIH0gZnJvbSAidnVlIjsKY29uc3QgX2hvaXN0ZWRfMSA9IHsKICBjbGFzczogInNpZGVtZW51Igp9OwpleHBvcnQgZnVuY3Rpb24gcmVuZGVyKF9jdHgsIF9jYWNoZSwgJHByb3BzLCAkc2V0dXAsICRkYXRhLCAkb3B0aW9ucykgewogIHJldHVybiBfb3BlbkJsb2NrKCksIF9jcmVhdGVFbGVtZW50QmxvY2soX0ZyYWdtZW50LCBudWxsLCBbX2NyZWF0ZVZOb2RlKCRzZXR1cFsiVG9wTWVudSJdLCB7CiAgICBvblN1Ym1pdE9iamVjdDogJHNldHVwLnN1Ym1pdEZsb3djaGFydAogIH0pLCBfY3JlYXRlQ29tbWVudFZOb2RlKCIgQGNoZWNrVHVybjE9XCJjaGVja091dHB1dFwiICIpLCBfY3JlYXRlRWxlbWVudFZOb2RlKCJkaXYiLCB7CiAgICBjbGFzczogImRuZGZsb3ciLAogICAgb25Ecm9wOiAkc2V0dXAub25Ecm9wCiAgfSwgW19jcmVhdGVFbGVtZW50Vk5vZGUoImRpdiIsIF9ob2lzdGVkXzEsIFtfY3JlYXRlVk5vZGUoJHNldHVwWyJGYWNlSW1hZ2UiXSksIF9jcmVhdGVWTm9kZSgkc2V0dXBbIk5vZGVTZXR0aW5ncyJdKSwgX2NyZWF0ZVZOb2RlKCRzZXR1cFsiTm9kZUZpZWxkIl0pXSksIF9jcmVhdGVWTm9kZSgkc2V0dXBbIlZ1ZUZsb3ciXSwgewogICAgY2xhc3M6ICJiYXNpY2Zsb3ciLAogICAgbW9kZWxWYWx1ZTogJHNldHVwLmVsZW1lbnRzLAogICAgIm9uVXBkYXRlOm1vZGVsVmFsdWUiOiBfY2FjaGVbMF0gfHwgKF9jYWNoZVswXSA9ICRldmVudCA9PiAkc2V0dXAuZWxlbWVudHMgPSAkZXZlbnQpLAogICAgIm5vZGUtdHlwZXMiOiAkc2V0dXAubm9kZVR5cGVzLAogICAgImRlZmF1bHQtem9vbSI6IDEuNSwKICAgICJtaW4tem9vbSI6IDAuMiwKICAgICJtYXgtem9vbSI6IDQsCiAgICAiZml0LXZpZXctb24taW5pdCI6IHRydWUsCiAgICAic25hcC10by1ncmlkIjogdHJ1ZSwKICAgICJjb25uZWN0aW9uLW1vZGUiOiAkc2V0dXAuQ29ubmVjdGlvbk1vZGUuTG9vc2UsCiAgICBvbkRyYWdvdmVyOiAkc2V0dXAub25EcmFnT3ZlciwKICAgIG9uUGFuZVJlYWR5OiAkc2V0dXAub25Mb2FkLAogICAgb25TZWxlY3Rpb25Db250ZXh0TWVudTogJHNldHVwLnNlbGVjdE1lbnUsCiAgICBvbkNvbnRleHRtZW51OiBfY2FjaGVbMV0gfHwgKF9jYWNoZVsxXSA9IF93aXRoTW9kaWZpZXJzKCRldmVudCA9PiAkc2V0dXAuaGFuZGxlQ2xpY2soJGV2ZW50KSwgWyJwcmV2ZW50IiwgInN0b3AiXSkpCiAgfSwgewogICAgIm5vZGUtTWFrZSI6IF93aXRoQ3R4KHByb3BzID0+IFtfY3JlYXRlVk5vZGUoJHNldHVwWyJNYWtlTm9kZSJdLCBfbm9ybWFsaXplUHJvcHMoX2d1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcykpLCBudWxsLCAxNgogICAgLyogRlVMTF9QUk9QUyAqLwogICAgKV0pLAogICAgIm5vZGUtTW90aXZhdGlvbiI6IF93aXRoQ3R4KHByb3BzID0+IFtfY3JlYXRlVk5vZGUoJHNldHVwWyJNb3RpdmF0aW9uTm9kZSJdLCBfbm9ybWFsaXplUHJvcHMoX2d1YXJkUmVhY3RpdmVQcm9wcyhwcm9wcykpLCBudWxsLCAxNgogICAgLyogRlVMTF9QUk9QUyAqLwogICAgKV0pLAogICAgIm5vZGUtU2Vhc29uIjogX3dpdGhDdHgocHJvcHMgPT4gW19jcmVhdGVWTm9kZSgkc2V0dXBbIlNlYXNvbk5vZGUiXSwgX25vcm1hbGl6ZVByb3BzKF9ndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpKSwgbnVsbCwgMTYKICAgIC8qIEZVTExfUFJPUFMgKi8KICAgICldKSwKICAgICJub2RlLVRpbWUiOiBfd2l0aEN0eChwcm9wcyA9PiBbX2NyZWF0ZVZOb2RlKCRzZXR1cFsiVGltZU5vZGUiXSwgX25vcm1hbGl6ZVByb3BzKF9ndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpKSwgbnVsbCwgMTYKICAgIC8qIEZVTExfUFJPUFMgKi8KICAgICldKSwKICAgIGRlZmF1bHQ6IF93aXRoQ3R4KCgpID0+IFtfY3JlYXRlVk5vZGUoJHNldHVwWyJCYWNrZ3JvdW5kIl0sIHsKICAgICAgInBhdHRlcm4tY29sb3IiOiAiIzAwMDAwMCIsCiAgICAgIGdhcDogIjgiCiAgICB9KSwgX2NyZWF0ZVZOb2RlKCRzZXR1cFsiTWluaU1hcCJdKSwgX2NyZWF0ZVZOb2RlKCRzZXR1cFsiQ29udHJvbHMiXSksIF9jcmVhdGVFbGVtZW50Vk5vZGUoImRpdiIsIHsKICAgICAgY2xhc3M6ICJjb250cm9scyIKICAgIH0sIFtfY3JlYXRlRWxlbWVudFZOb2RlKCJidXR0b24iLCB7CiAgICAgIHN0eWxlOiB7CiAgICAgICAgImJhY2tncm91bmQtY29sb3IiOiAiIzE5MTk3MCIsCiAgICAgICAgImNvbG9yIjogIndoaXRlIgogICAgICB9LAogICAgICBvbkNsaWNrOiAkc2V0dXAucmVzZXRUcmFucwogICAgfSwgInJlc2V0IHRyYW5zZm9ybSIpLCBfY3JlYXRlRWxlbWVudFZOb2RlKCJidXR0b24iLCB7CiAgICAgIG9uQ2xpY2s6ICRzZXR1cC5sb2dUb09iamVjdAogICAgfSwgImxvZyB0b09iamVjdCIpXSksIF9jcmVhdGVWTm9kZSgkc2V0dXBbIlZ1ZVNpbXBsZUNvbnRleHRNZW51Il0sIHsKICAgICAgImVsZW1lbnQtaWQiOiAibXlVbmlxdWVJZCIsCiAgICAgIG9wdGlvbnM6ICRzZXR1cC5vcHRpb25zLAogICAgICByZWY6ICJ2dWVDb250ZXh0TWVudSIsCiAgICAgIG9uT3B0aW9uQ2xpY2tlZDogJHNldHVwLm9wdGlvbkNsaWNrZWQKICAgIH0sIG51bGwsIDUxMgogICAgLyogTkVFRF9QQVRDSCAqLwogICAgKV0pLAogICAgXzogMQogICAgLyogU1RBQkxFICovCgogIH0sIDgKICAvKiBQUk9QUyAqLwogICwgWyJtb2RlbFZhbHVlIiwgImRlZmF1bHQtem9vbSIsICJtaW4tem9vbSIsICJjb25uZWN0aW9uLW1vZGUiXSldLCAzMgogIC8qIEhZRFJBVEVfRVZFTlRTICovCiAgKV0sIDY0CiAgLyogU1RBQkxFX0ZSQUdNRU5UICovCiAgKTsKfQ=="},{"version":3,"mappings":";;EA8lBSA,KAAK,EAAC;;;6DAFbC,aAA2CC,iBAA3C,EAA2C;IAAjCC,cAAY,EAAED;EAAmB,CAA3C,GAA4CE,sDAC5CC,oBAyCM,KAzCN,EAyCM;IAzCDL,KAAK,EAAC,SAyCL;IAzCgBM,MAAI,EAAEJ;EAyCtB,CAzCN,GACEG,oBAIM,KAJN,cAIM,CAHJJ,aAAaC,mBAAb,CAGI,EAFJD,aAAgBC,sBAAhB,CAEI,EADJD,aAAaC,mBAAb,CACI,CAJN,GAKAD,aAkCUC,iBAlCV,EAkCU;IAjCRF,KAAK,EAAC,WAiCE;gBAjCmBE,eAiCnB;+DAjCmBA,kBAAQK,OAiC3B;IAhCP,cAAYL,gBAgCL;IAhCiB,gBAAc,GAgC/B;IAhCqC,YAAU,GAgC/C;IAhCqD,YAAU,CAgC/D;IA/BP,oBAAkB,IA+BX;IA/BkB,gBAAc,IA+BhC;IA/BuC,mBAAiBA,sBAAeM,KA+BvE;IA9BPC,UAAQ,EAAEP,iBA8BH;IA9BgBQ,WAAU,EAAER,aA8B5B;IA9BqCS,sBAAsB,EAAET,iBA8B7D;IA7BPU,aAAW,qDAAeV,mBAAYK,MAAZ,CAAf,EAAiC,mBAAjC;EA6BJ,CAlCV;IAea,aAASM,SAAEC,KACpB,IADyB,CACzBb,aAA2BC,kBAA3B,EAA2Ba,oCAATD,KAAS,EAA3B,EAAuB,IAAvB,EAAuB;IAAA;IAAvB,CADyB,CAAP;IAGT,mBAAeD,SAAEC,KAC1B,IAD+B,CAC/Bb,aAAiCC,wBAAjC,EAAiCa,oCAATD,KAAS,EAAjC,EAA6B,IAA7B,EAA6B;IAAA;IAA7B,CAD+B,CAAP;IAGf,eAAWD,SAAEC,KACtB,IAD2B,CAC3Bb,aAA6BC,oBAA7B,EAA6Ba,oCAATD,KAAS,EAA7B,EAAyB,IAAzB,EAAyB;IAAA;IAAzB,CAD2B,CAAP;IAGX,aAASD,SAAEC,KACpB,IADyB,CACzBb,aAA2BC,kBAA3B,EAA2Ba,oCAATD,KAAS,EAA3B,EAAuB,IAAvB,EAAuB;IAAA;IAAvB,CADyB,CAAP;sBAjBpB,MAA8C,CAA9Cb,aAA8CC,oBAA9C,EAA8C;MAAlC,iBAAc,SAAoB;MAAVc,GAAG,EAAC;IAAM,CAA9C,CAA8C,EAC9Cf,aAAWC,iBAAX,CAD8C,EAE9CD,aAAYC,kBAAZ,CAF8C,EAG9CG,oBAGM,KAHN,EAGM;MAHDL,KAAK,EAAC;IAGL,CAHN,EAAqB,CACnBK,oBAAqG,QAArG,EAAqG;MAA7FY,KAAgD,EAAhD;QAAA;QAAA;MAAA,CAA6F;MAA3CC,OAAK,EAAEhB;IAAoC,CAArG,EAA6E,iBAA7E,CADmB,EAEnBG,oBAAkD,QAAlD,EAAkD;MAAzCa,OAAK,EAAEhB;IAAkC,CAAlD,EAA6B,cAA7B,CAFmB,CAArB,CAH8C,EAqB9CD,aAKEC,8BALF,EAKE;MAJA,cAAW,YAIX;MAHCiB,OAAO,EAAEjB,cAGV;MAFAkB,GAAG,EAAC,gBAEJ;MADCC,eAAc,EAAEnB;IACjB,CALF;;IAAA,CArB8C;;;;GAPhD;;EAAA,iEANF;;EAAA","names":["class","_createVNode","$setup","onSubmitObject","_createCommentVNode","_createElementVNode","onDrop","$event","Loose","onDragover","onPaneReady","onSelectionContextMenu","onContextmenu","_withCtx","props","_normalizeProps","gap","style","onClick","options","ref","onOptionClicked"],"sourceRoot":"","sources":["/Users/takanosayaka/Documents/GitHub/makeup_flowchart_vue3/src/views/Flowchart.vue"],"sourcesContent":["<script setup>\nimport { Background, Controls, MiniMap, VueFlow, isEdge, MarkerType, ConnectionMode, useVueFlow, } from '@braks/vue-flow'\nimport { markRaw, ref, } from 'vue'\nimport { useStore } from 'vuex'\nimport { useRouter } from 'vue-router'\nimport { testInitialElements } from '../js/initial-elements.js'\n//カスタムノードの追加\nimport MakeNode from '@/components/MakeNode.vue'\nimport MotivationNode from '@/components/MotivationNode.vue'\nimport SeasonNode from '@/components/SeasonNode.vue'\nimport TimeNode from '@/components/TimeNode.vue'\n//子コンポーネントの追加\nimport NodeSettings from '@/components/NodeSettings.vue'\nimport FaceImage from '@/components/FaceImage.vue'\nimport NodeField from '@/components/NodeField.vue'\nimport TopMenu from '@/components/TopMenu.vue'\n//ライブラリの追加\nimport VueSimpleContextMenu from 'vue-simple-context-menu';\nimport 'vue-simple-context-menu/dist/vue-simple-context-menu.css';\nimport axios from \"axios\"\n\n//初期設定\n/* vue-flowの初期設定 */\nconst { onPaneReady, onConnect, onEdgesChange, onNodesChange, addEdges, addNodes, setTransform, toObject, project, getNode, getEdge, } = useVueFlow()\nconst elements = ref(testInitialElements)\nconst nodeTypes = {\n  customMake: markRaw(MakeNode),\n  customMotivation: markRaw(MotivationNode),\n  customSeason: markRaw(SeasonNode),\n  customTime: markRaw(TimeNode),\n}\n/* storeとrouterの開始 */\nconst store = useStore()\nconst router = useRouter()\n/* ノードの管理変数 */\nvar Skeys = [] //source\nvar edgeSNum = [] //sourceから見たedgeの重複 source:[id]\nvar makeNodeNum = {0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: []} //imgNum:[id]\n/* vue-simple-context-menuの初期設定 */\nconst options = [{name: \"Copy\", slug: \"copy\"}]\nconst vueContextMenu = ref(testInitialElements)\n\n\n/* vue-simple-context-menuの関数 */\nconst handleClick =  (event) => {\n  // overwrite readonly properties pageX and pageY and set correct values\n  Object.defineProperty(event, 'pageX', {\n    value: event.pageX - 350,\n    writable: true\n  })\n  Object.defineProperty(event, 'pageY', {\n    value: event.pageY - 100,\n    writable: true\n  })\n  vueContextMenu.value.showMenu(event)\n}\n//コンテキストメニューを呼び出す\nconst selectMenu = (params) => {\n  store.commit(\"setSelectNodeList\", params.nodes)\n}\n//コンテキストメニューのクリック\nconst optionClicked = () => {\n  var copyNode\n  var copyNodesData = store.state.selectnodeList\n  for(var s=0; s<copyNodesData.length; s++){\n    var copyNodeData = store.state.selectnodeList[s]\n    if(copyNodeData.type == 'input' || copyNodeData.type == 'output'){\n      //開始ノードか終了ノード\n      copyNode = {\n        id: ss_getId(),\n        type: copyNodeData.type,\n        position: project({ x: copyNodeData.position.x + 100, y: copyNodeData.position.y + 100 }),\n        label: copyNodeData.label,\n      }\n    }else if(copyNodeData.type == 'customMake'){\n      //メイクノード\n      copyNode = {\n        id: m_getId(),\n        type: copyNodeData.type,\n        position: project({ x: copyNodeData.position.x + 100, y: copyNodeData.position.y + 100 }),\n        label: copyNodeData.label,\n        style: copyNodeData.style,\n        data: copyNodeData.data,\n      }\n    }else{\n      //分岐（ブランチ）ノード\n      copyNode = {\n        id: copyNodeData.type == 'customMotivation'\n          ? mv_getId()\n          : copyNodeData.type == 'customSeason'\n            ? s_getId()\n            : t_getId(),\n        type: copyNodeData.type,\n        position: project({ x: copyNodeData.position.x + 100, y: copyNodeData.position.y + 100 }),\n        label: copyNodeData.label,\n        style: copyNodeData.style,\n      }\n    }\n    addNodes([copyNode])\n  }\n}\n\n/* 起動時の挙動 */\n//onPaneReadyは、viewpaneとノードに表示可能なディメンションがある場合に呼び出されます\nonPaneReady(({fitView}) => {\n  fitView()\n})\nconst onLoad = (flowInstance) => flowInstance.fitView()\n\n/* 対象のノードとエッジの調査 */\n//対象エッジと同じノードから出ているエッジの本数を返す(return)\nconst surveySameSource = (source) => {\n  if(Skeys.includes(source)){\n    var temp2 = edgeSNum[source]\n    return temp2.length\n  }else{\n    return 0\n  }\n}\n//対象エッジの追加/削除に伴うSkeysとedgeSNumの更新\nconst changeEdges = (edge, type) => {\n  //データ受け取り\n  var eid = edge.id\n  var source = edge.source\n  //Skeysの更新\n  Skeys = Object.keys(edgeSNum)\n  if(type == \"add\"){\n    console.log(\"edgeSNumの更新(追加)\")\n    if(Skeys.includes(source)){\n      edgeSNum[source].push(eid)\n    }else{\n      edgeSNum[source] = []\n      edgeSNum[source].push(eid)\n      Skeys = Object.keys(edgeSNum)\n    }\n  }else if(type == \"remove\"){\n    console.log(\"edgeSNumの更新(削除)\")\n    var sameEdgeSNum = edgeSNum[source]\n    if(sameEdgeSNum.length >= 2){\n      for(var j=0; j<sameEdgeSNum.length; j++){\n        if(sameEdgeSNum[j] == eid){\n          edgeSNum[source].splice(j, 1)\n        }\n      }\n    }else{\n      delete edgeSNum[source]\n      Skeys = Object.keys(edgeSNum)\n    }\n  }else if(type == \"change\"){\n    console.log(\"edgeSNumの更新(変更)\")\n  }else{\n    return\n  }\n}\n//対象メイクノードの追加/削除時のmakeNodeNumの値と表示イラストの更新\nconst changeMakeNodes = (nodeData) => {\n  if(nodeData.type == \"add\"){\n    makeNodeNum[nodeData.imgNum].push(nodeData.id)\n  }else if(nodeData.type == \"remove\"){\n    var lengthNum = makeNodeNum[nodeData.imgNum]\n    for(var n=0; n<lengthNum.length; n++){\n      if(lengthNum[n] == nodeData.id){\n        makeNodeNum[nodeData.imgNum].splice(n, 1)\n      }\n    }\n  }else{\n    return\n  }\n\n  //メイクノードの追加/削除に伴う表示イラストの更新\n  for(var l=0; l<Object.keys(makeNodeNum).length; l++){\n    var tempLengthNum = makeNodeNum[l]\n    if(tempLengthNum.length >= 1){\n      store.commit(\"setMakeNodeList\", {imgNum:l, imgState: true})\n    }else{\n      store.commit(\"setMakeNodeList\", {imgNum:l, imgState: false})\n    }\n  }\n}\n//turn2に移る前にメイク終了ノードが設置されているか確認する\n/*\nconst checkOutput = () => {\n  elements.value.forEach((el) => {\n    if (isNode(el)) {\n    }\n  })\n}\n*/\n\n/* ノードの変更時に発火する関数 */\nonNodesChange((params) => {\n  //type: dimensions(配置？/サイズ情報), select, add, remove\n  //params add:[type, item{}] remove:[type, id] select:[type, id, selected]\n  for(var q=0; q<params.length; q++){\n    if(params[q].type == \"add\"){\n      console.log(\"ノードの追加\")\n      //メイクノードだったら\n      if(params[q].item.type == \"customMake\"){\n        var nodeitems = params[q].item\n        var nodeData = nodeitems.data\n        //化粧工程の判定\n        if(nodeData.partNum == 1 && nodeData.itemNum == 8){\n          changeMakeNodes({imgNum: 0, id: nodeitems.id, type: \"add\"})\n        }else if(nodeData.partNum == 1 && nodeData.itemNum == 8 && nodeData.typeNum == 2){\n          changeMakeNodes({imgNum: 1, id: nodeitems.id, type: \"add\"})\n        }else if(nodeData.partNum == 2 && nodeData.itemNum == 11){\n          changeMakeNodes({imgNum: 2, id: nodeitems.id, type: \"add\"})\n        }else if(nodeData.partNum == 2 && (13 <= nodeData.itemNum && nodeData.itemNum <= 16)){\n          changeMakeNodes({imgNum: 3, id: nodeitems.id, type: \"add\"})\n        }else if(nodeData.partNum == 2 && (17 <= nodeData.itemNum && nodeData.itemNum <= 20)){\n          changeMakeNodes({imgNum: 4, id: nodeitems.id, type: \"add\"})\n        }else if(nodeData.partNum == 4 && nodeData.itemNum == 24){\n          changeMakeNodes({imgNum: 5, id: nodeitems.id, type: \"add\"})\n        }else if(nodeData.partNum == 4 && nodeData.itemNum == 25){\n          changeMakeNodes({imgNum: 6, id: nodeitems.id, type: \"add\"})\n        }else if(nodeData.partNum == 0 && nodeData.itemNum == 22){\n          changeMakeNodes({imgNum: 7, id: nodeitems.id, type: \"add\"})\n        }else{\n          return\n        }\n      }\n    }else if(params[q].type == \"remove\"){\n      console.log(\"ノードの削除\")\n      if(params[q].id.indexOf('make') > -1){ //メイクノードだったら\n        const rnode = getNode.value(params[q].id)\n        const rdata = rnode.data\n        if(rdata.partNum == 1 && rdata.itemNum == 8){\n          changeMakeNodes({imgNum: 0, id: params[q].id, type: \"remove\"})\n        }else if(rdata.partNum == 1 && rdata.itemNum == 8 && rdata.typeNum == 2){\n          changeMakeNodes({imgNum: 1, id: params[q].id, type: \"remove\"})\n        }else if(rdata.partNum == 2 && rdata.itemNum == 11){\n          changeMakeNodes({imgNum: 2, id: params[q].id, type: \"remove\"})\n        }else if(rdata.partNum == 2 && (13 <= rdata.itemNum && rdata.itemNum <= 16)){\n          changeMakeNodes({imgNum: 3, id: params[q].id, type: \"remove\"})\n        }else if(rdata.partNum == 2 && (17 <= rdata.itemNum && rdata.itemNum <= 20)){\n          changeMakeNodes({imgNum: 4, id: params[q].id, type: \"remove\"})\n        }else if(rdata.partNum == 4 && rdata.itemNum == 24){\n          changeMakeNodes({imgNum: 5, id: params[q].id, type: \"remove\"})\n        }else if(rdata.partNum == 4 && rdata.itemNum == 25){\n          changeMakeNodes({imgNum: 6, id: params[q].id, type: \"remove\"})\n        }else if(rdata.partNum == 0 && rdata.itemNum == 22){\n          changeMakeNodes({imgNum: 7, id: params[q].id, type: \"remove\"})\n        }else{\n          return\n        }\n      }\n    }else if(params[q].type == \"select\"){\n      var snode\n      if(params[q].id.indexOf('make') > -1 || params[q].id.indexOf('branch') > -1){\n        //メイクノードかブランチノードだったら\n        snode = getNode.value(params[q].id)\n        if(params[q].selected){\n          snode.style['--vf-node-color'] = '#3cb371'\n        }else{\n          snode.style['--vf-node-color'] = 'black'\n        }\n      }\n      if(store.state.turn == 2){\n        if(params[q].id.indexOf('make') > -1){\n          //メイクノードだったら\n          if(params[q].selected){\n            if(!snode.data[\"skip\"]){\n              //skipがfalseだったら\n              snode.style['--vf-node-text'] = '#ff8c00'\n              snode.data[\"skip\"] = true\n            }else{\n              //skipがtrueだったら\n              snode.style['--vf-node-text'] = 'black'\n              snode.data[\"skip\"] = false\n            }\n          }\n        }\n      }else if(store.state.turn == 3){\n        if(params[q].id.indexOf('make') > -1){\n          //メイクノードだったら\n          if(params[q].selected){\n            if(!snode.data[\"forget\"]){\n              //forgetがfalseだったら\n              snode.style[\"--vf-node-bg\"] = \"pink\"\n              snode.data[\"forget\"] = true\n            }else{\n              //forgetがtrueだったら\n              snode.style[\"--vf-node-bg\"] = \"white\"\n              snode.data[\"forget\"] = false\n            }\n          }\n        }\n      }\n    }\n    else{\n      return\n    }\n  }\n})\n/* エッジの変更時に発火する関数 */\nonEdgesChange((params) => {\n  var NumOfSameSources\n  //params add:[type, item{}]  remove:[type, id]  select:[type, id, selected]\n  for(var i=0; i<params.length; i++){\n    if(params[i].type == \"add\"){\n      var edgeItem = params[i].item\n      //edgeSNumに新しいエッジを追加する\n      Skeys = Object.keys(edgeSNum) //最新版に更新\n      if(Skeys.includes(edgeItem.source)){\n        edgeSNum[edgeItem.source].push(edgeItem.id)\n      }else{\n        edgeSNum[edgeItem.source] = []\n        edgeSNum[edgeItem.source].push(edgeItem.id)\n        Skeys = Object.keys(edgeSNum)\n      }\n      //追加するエッジと同じsourceのエッジが何本あるか調べる\n      NumOfSameSources = surveySameSource(edgeItem.source)\n      //エッジが現状で1本以上あったらエッジをsmoothstepに切り替える\n      if(NumOfSameSources >= 1){\n        elements.value.forEach((el) => {\n          if (isEdge(el) && el.source == edgeItem.source) {\n            el.type = \"smoothstep\"\n          }\n        })\n      }\n    }else if(params[i].type == \"remove\"){\n      var source\n      var edgeData\n      //消すエッジと同じsourceのエッジが何本あるか調べる\n      elements.value.forEach((el) => {\n        if (el.id == params[i].id) {\n          edgeData = el\n          source = el.source\n          NumOfSameSources = surveySameSource(source)\n        }\n      })\n      //エッジが現状で2本以下だったらエッジをstraightに切り替える\n      if(NumOfSameSources == 2){\n        elements.value.forEach((el) => {\n          if (isEdge(el) && el.source == source) {\n            el.type = \"straight\"\n          }\n        })\n      }\n      //edgeListの状態変更\n      changeEdges(edgeData, \"remove\")\n    }else if(params[i].type == \"select\"){\n      var sedge = getEdge.value(params[i].id)\n      if(params[i].selected){\n        sedge.animated = true\n        //turn2だったらラベル設定用にidを保存する\n        if(store.state.turn == 2){\n          store.commit(\"setEdgeId\", params[i].id)\n        }\n      }else{\n        sedge.animated = false\n        //turn2だったらラベル設定用にidを保存する\n        if(store.state.turn == 2){\n          store.commit(\"setEdgeId\", \"\")\n        }\n      }\n    }else{\n      return\n    }\n  }\n})\n/* エッジの追加時に発火する関数 onConnect->onEdgesChange */\nonConnect((params) => {\n  console.log(\"エッジの追加\")\n  //params:[source, sourceHandle, target, targetHandle]\n\n  //同じソースのエッジの本数を取得する\n  var NumOfEdge\n  Skeys = Object.keys(edgeSNum)\n  if(Skeys.includes(params.source)){\n    NumOfEdge = surveySameSource(params.source) +1\n  }else{\n    NumOfEdge = 1\n  }\n\n  //新しいエッジの追加\n  var newEdge\n  const getEdgeId = () => `e${params.source}_${params.target}`\n  if(NumOfEdge < 3){\n    if(params.source.indexOf('make') > -1){\n      //customMakeだったら\n      if(NumOfEdge < 2){\n        newEdge = {\n          id: getEdgeId(),\n          source: params.source,\n          target: params.target,\n          type: 'straight',\n          style: { stroke: 'black' },\n          markerEnd: MarkerType.ArrowClosed,\n          animated: false,\n        }\n      }else{\n        //メイクノードではエッジを1本しか生やせない\n        alert(\"1つの化粧ノードから出せる矢印は1本だけです.追加で分岐させたい場合は分岐ノードを繋げてください\")\n        return\n      }\n    }else if(params.source.indexOf('branch') > -1){\n      //customBranchだったら\n      var addEdgeLabel\n      var addEdgeColor\n      var addEdgeType\n      if(params.source.indexOf('mvbranch') > -1){\n        //やる気ノード\n        addEdgeLabel = NumOfEdge%2 == 0 ? \"なし\" : \"あり\"\n        addEdgeColor = NumOfEdge%2 == 0 ? 'blue' : 'red'\n        addEdgeType = NumOfEdge%2 == 0 ? 'no' : 'max'\n      }else if(params.source.indexOf('sbranch') > -1){\n        //季節ノード\n        addEdgeLabel = NumOfEdge%2 == 0 ? \"冬\" : \"夏\"\n        addEdgeColor = NumOfEdge%2 == 0 ? 'gray' : 'blue'\n        addEdgeType = NumOfEdge%2 == 0 ? 'winter' : 'summer'\n      }else{\n        //時間ノード\n        addEdgeLabel = NumOfEdge%2 == 0 ? \"短い\" : \"長い\"\n        addEdgeColor = NumOfEdge%2 == 0 ? 'blue' : 'red'\n        addEdgeType = NumOfEdge%2 == 0 ? 'short' : 'long'\n      }\n      newEdge = {\n        id: getEdgeId(),\n        source: params.source,\n        target: params.target,\n        type: NumOfEdge>1 ? 'smoothstep' : 'straight',\n        label: addEdgeLabel,\n        style: { stroke: addEdgeColor },\n        labelStyle: { fill: 'white' },\n        labelBgStyle: { fill: addEdgeColor },\n        markerEnd: MarkerType.ArrowClosed,\n        animated: false,\n        data: {\n          type: addEdgeType\n        },\n      }\n    }else{\n      //input/outputだったら\n      if(NumOfEdge < 2){\n        newEdge = {\n          id: getEdgeId(),\n          source: params.source,\n          target: params.target,\n          type: 'straight',\n          style: { stroke: 'black' },\n          markerEnd: MarkerType.ArrowClosed,\n          animated: false,\n        }\n      }else{\n        //メイクノードではエッジを1本しか生やせない\n        alert(\"1つのメイク開始/終了ノードから出せる矢印は1本だけです.追加で分岐させたい場合は分岐ノードを繋げてください\")\n        return\n      }\n    }\n  }else{\n    //新しく足すエッジが3本目だったら追加させない\n    alert(\"1つのノードから出せる矢印は2本までです.追加で分岐させたい場合は分岐ノードを繋げてください\")\n    return\n  }\n  addEdges([newEdge])\n})\n\n/* マウス操作に結びつけた関数 */\n//ノードのドラッグ操作\nconst onDragOver = (event) => {\n  event.preventDefault()\n  if (event.dataTransfer) {\n    event.dataTransfer.dropEffect = 'move'\n  }\n}\n//ノードのドロップによる，新規ノードの追加\nlet id = 0\nconst ss_getId = () => `ss_${id++}`\nconst m_getId = () => `make_${id++}`\nconst mv_getId = () => `mvbranch_${id++}`\nconst s_getId = () => `sbranch_${id++}`\nconst t_getId = () => `tbranch_${id++}`\nconst onDrop = (event) => {\n  const type = event.dataTransfer?.getData('application/vueflow')\n  const position = project({ x: event.clientX - 400, y: event.clientY - 150 })\n  var newNode\n  if(type == 'input' || type == 'output'){\n    //開始ノードか終了ノード\n    newNode = {\n      id: ss_getId(), type, position,\n      label: type == 'input' ? `メイク開始` : `メイク終了`,\n    }\n  }else if(type == 'customMake'){\n    //メイクノード\n    newNode = {\n      id: m_getId(),\n      type, position,\n      label: store.state.itemName.length >= 7\n        ? store.state.itemName+\"\\n(\"+store.state.typeName+\")\"\n        : store.state.itemName+\"(\"+store.state.typeName+\")\",\n      style: { '--vf-node-color': 'black' },\n      data: {\n        partName: store.state.partName,\n        partNum: store.state.partNum,\n        itemName: store.state.itemName,\n        itemNum: store.state.itemNum,\n        typeName: store.state.typeName,\n        typeNum: store.state.typeNum,\n        skip: false,\n        forget: false,\n      }\n    }\n  }else{\n    //分岐ノード\n    var nodeLabel\n    var nodeId\n    if(type == 'customMotivation'){\n      nodeLabel = \"気合い\"\n      nodeId = mv_getId()\n    }else if(type == 'customSeason'){\n      nodeLabel = \"季節\"\n      nodeId = s_getId()\n    }else{\n      nodeLabel = \"外出時間\"\n      nodeId = t_getId()\n    }\n    newNode = {\n      id: nodeId,\n      type, position,\n      label: nodeLabel,\n      style: { '--vf-node-color': 'black' },\n    }\n  }\n  addNodes([newNode])\n}\n\n/* vueFlow上のボタン操作 */\n//現在のviewpaneの変換 (ズームとパン) をリセット\nconst resetTrans = () => {\n  setTransform({ x: 0, y: 0, zoom: 1 })\n}\n//toObjectは、現在のグラフデータを簡単に永続化できるオブジェクトに変換\nconst logToObject = () => {\n  console.log(\"データのmysqlへの送信\")\n  const params = new URLSearchParams()\n  params.append('userId', store.state.userId)\n  params.append('userName', store.state.userName)\n  params.append('flowchart', JSON.stringify(toObject()))\n  axios.post('https://takano.nkmr.io/flowchart_post.php', params)\n  .then((response)=>{\n    //上手く行った時\n    console.log('status:',response.status)\n  }).catch((error)=>{\n    //失敗した時\n    console.log('err:',error)\n  })\n  //フローチャートデータのダウンロード\n  /*\n  const fileName = store.state.userName+\".json\"\n  const flowData = JSON.stringify(toObject())\n  const link = document.createElement(\"a\")\n  link.href = \"data:text/plain,\" + encodeURIComponent(flowData)\n  link.download = fileName\n  link.click()\n  */\n  //フローチャート画像のダウンロード\n  var svg = document.querySelector('.basicflow')\n  var svgData = new XMLSerializer().serializeToString(svg)\n  var canvas = document.createElement(\"canvas\")\n  canvas.width = \"800px\" //svg.width.baseVal.value\n  canvas.height = \"760px\" //svg.height.baseVal.value\n\n  var ctx = canvas.getContext(\"2d\")\n  var image = new Image\n  image.onload = function(){\n    ctx.drawImage( image, 0, 0 )\n    var a = document.createElement(\"a\")\n    a.href = canvas.toDataURL(\"image/png\")\n    a.setAttribute(\"download\", store.state.userName+\".png\")\n    a.dispatchEvent(new MouseEvent(\"click\"))\n  }\n  image.src = \"data:image/svg+xml;charset=utf-8;base64,\" + btoa(unescape(encodeURIComponent(svgData)))\n}\n\nconst submitFlowchart = () => {\n  console.log(\"データのmysqlへの送信&実験終了\")\n  const params2 = new URLSearchParams()\n  params2.append('userId', store.state.userId)\n  params2.append('userName', store.state.userName)\n  params2.append('flowchart', JSON.stringify(toObject()))\n  axios.post('https://takano.nkmr.io/flowchart_post.php', params2)\n  .then((response)=>{\n    //上手く行った時\n    console.log('status:',response.status)\n  }).catch((error)=>{\n    //失敗した時\n    console.log('err:',error)\n  })\n  //フローチャートデータのダウンロード\n  const fileName2 = store.state.userName+\".json\"\n  const flowData2 = JSON.stringify(toObject())\n  const link2 = document.createElement(\"a\")\n  link2.href = \"data:text/plain,\" + encodeURIComponent(flowData2)\n  link2.download = fileName2\n  link2.click()\n  //実験終了画面へ移動\n  setTimeout(function(){\n    router.push('/finish')\n  }, 3000)\n}\n</script>\n\n<template>\n  <TopMenu @submitObject=\"submitFlowchart\" /> <!-- @checkTurn1=\"checkOutput\" -->\n  <div class=\"dndflow\" @drop=\"onDrop\">\n    <div class=\"sidemenu\">\n      <FaceImage />\n      <NodeSettings />\n      <NodeField />\n    </div>\n    <VueFlow\n      class=\"basicflow\" v-model=\"elements\"\n      :node-types=\"nodeTypes\" :default-zoom=\"1.5\" :min-zoom=\"0.2\" :max-zoom=\"4\"\n      :fit-view-on-init=\"true\" :snap-to-grid=\"true\" :connection-mode=\"ConnectionMode.Loose\"\n      @dragover=\"onDragOver\" @pane-ready=\"onLoad\" @selection-context-menu=\"selectMenu\"\n      @contextmenu.prevent.stop=\"handleClick($event)\"\n    >\n      <Background pattern-color=\"#000000\" gap=\"8\" />\n      <MiniMap />\n      <Controls />\n      <div class=\"controls\">\n        <button style=\"background-color: #191970; color: white;\" @click=\"resetTrans\">reset transform</button>\n        <button @click=\"logToObject\">log toObject</button>\n      </div>\n      <!--カスタムノードの設定-->\n      <template #node-Make=\"props\">\n        <MakeNode v-bind=\"props\" />\n      </template>\n      <template #node-Motivation=\"props\">\n        <MotivationNode v-bind=\"props\" />\n      </template>\n      <template #node-Season=\"props\">\n        <SeasonNode v-bind=\"props\" />\n      </template>\n      <template #node-Time=\"props\">\n        <TimeNode v-bind=\"props\" />\n      </template>\n      <!--context-menuの設定-->\n      <vue-simple-context-menu\n        element-id=\"myUniqueId\"\n        :options=\"options\"\n        ref=\"vueContextMenu\"\n        @option-clicked=\"optionClicked\"\n      />\n    </VueFlow>\n  </div>\n</template>\n\n<style>\n@import '../css/flowchart.css';\n</style>"]}]}